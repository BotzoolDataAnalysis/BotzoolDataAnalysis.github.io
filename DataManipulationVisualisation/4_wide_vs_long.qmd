---
title: "4 Wide vs long format"
author: "Irena Axmanová"
---

In this chapter, we will examine various data formats and learn how to convert between them. We will define groups within the data and calculate several statistics for them using summarise functions.

## 4.1 Data formats

There are two main ways in which the data can be organised across rows and columns—wide or long format. We will show you an example of spruce forest data, where we recorded plant species in several sites and at each site we also estimated their abundance, here approximated as percentage cover (higher value means that the species covered larger area of the surveyed vegetation plot, but we do not give the area itself, but value it relatively to the total area, i.e. percentage of total area). The covers of species might overlap, as they grow in different heights.

![](images/clipboard-1036617063.png)

**Wide format** is more conservative and used in many older packages for ecological data analysis. In our example, we list all species, and the columns are used to indicate their abundance at each site. This is the way you need to prepare your species matrix for ordinations in `vegan`. However, wide format also has many cons.

One of them is the file size. In the example above, there is an abundance of given plants in each of the sites. When a species is present at only one site, such as *Trientalis europaea*, it still occupies space across the entire table, where there can be hundreds or thousands of sites. The table code, of course, is memory-demanding.

One more point. For many ecological analyses, you cannot keep the empty cells empty, since they are recognised as NAs. Therefore, you must take an additional step and fill them with zeros.

Another disadvantage is that it is not easy to add new information to the listed species. For example, if you want to separate species that are in a tree vegetation layer (recognised in vegetation ecology as 1), a herb layer (6), and a moss layer (9), you would have to add this information to the species name, e.g., *Picea_abies_1*. Can you see a conflict with the basic principles of tidyverse?

![](images/clipboard-2355429167.png)

**Long format,** in contrast, is excellent for handling large datasets. Imagine we have more sites than those shown in the example above. In this format, we list all the species for Site1, then for Site2, and so on. However, we list only the species that are actually present! By simply counting the rows belonging to each site, you have the information about the overall species richness.

We can also add any information that describes the data, such as vegetation layers, growth forms, native/alien status, etc. After that, we can very simply filter, summarise and calculate further statistics.

## 4.2 From long to wide

We will first start a new script for this chapter and load the libraries. Remember to keep the script tidy and include your remarks.

```{r}
#| warning: false
library(tidyverse)
library(readxl)
library(janitor)
```

Now, we will import the data. In the first example, we will again use the `Forest understory data` from our folder: [`Link to Github folder`](https://github.com/BotzoolDataAnalysis/BotzoolDataAnalysis.github.io/tree/main/DataManipulationVisualisation/data). However, this time we will upload the species data saved in a long format, and we will prepare a species matrix in a wide format, so that it can be used in specific ecological analyses, e.g. in `vegan`.

```{r}
spe <- read_excel("data/forest_understory/Axmanova-Forest-spe.xlsx")
tibble(spe)
```

We can see that there are plant species names sorted by RELEVE_NR, where each number indicates a vegetation record from a specific site (also known as a vegetation plot or sample). We will rename this to make it easier for us as PlotID. Furthermore, we may need to modify the species names to conform to the compact format, using underscores instead of spaces. For this, we will use the **`mutate()`** function with **`str_replace()`** (for string replacement), specifying that an underscore should replace each space, and apply it directly to the original column.

```{r}
spe %>% 
  rename(PlotID = RELEVE_NR) %>%
  mutate(Species = str_replace_all(Species, " ", "_"))
```

\*If you want to play a bit, you can create a new column (e.g. SpeciesNew) to see both the original name and the changed name.

```{r}
spe %>% 
  rename(PlotID = RELEVE_NR) %>%
  mutate(SpeciesNew = str_replace_all(Species, " ", "_"))
```

Note that, just as above, you can change different patterns, e.g., remove part of the strings. There are even more complex things we can do, but we will save them for later, as they require some knowledge of regular expression rules. Here, I created a new column where I removed the indication that the species belongs to a complex, i.e., the part of the string saying it is an aggregate. I also prepared a column "check" where I compare the new and old names to determine if they are equal or not, and filtered only those cases where they are not. This should show me exactly the changed rows. If I am satisfied with the result, I can then remove the lines using this check and even rewrite the original column.

```{r}
spe %>% 
  rename(PlotID = RELEVE_NR) %>%
  mutate(SpeciesNew = str_replace_all(Species, " agg.", "")) %>%
  mutate(check = (SpeciesNew == Species))%>% 
  filter(check == "FALSE") %>%
  select(PlotID, Species, SpeciesNew, check) #select only relevant to see at a first glance
```

We have the condensed name with underscores, but there are still more variables in the table. We can either remove them or merge them to be included in the final wide format. Here, we will deviate slightly from tidy rules and add the information about the vegetation layer directly to the variable Species using the **`unite()`** function from the `tidyr` package, which merges strings from two or more columns into a new one: **A+B =** **A_B**. Default separator is again underscore, unless you specify it differently by the `sep` argument.

![](images/clipboard-2085711370.png)Argument `na.rm` indicates what to do if in one of the combined columns there is no value but NA. We have set this argument to TRUE to remove the NA. If you keep it FALSE, it is possible that in some data, the new string will be a_NA or NA_b, or even NA_NA (see line 4 of our example).

The `remove` argument set to TRUE will remove the original columns that we used to combine the new one (in the example above, you will have only z). In our case, we will keep the original columns for visual checking, and we will use the `select()` function in the next step to remove them.

Note that the function that works in the opposite direction is called `separate()` or `separate_wider_delim()`.

```{r}
spe %>% 
  rename(PlotID = RELEVE_NR) %>%
  mutate(Species = str_replace_all(Species, " ", "_")) %>%
  unite("SpeciesLayer", Species, Layer, na.rm = TRUE, remove = FALSE) 
```

At this point, we have everything we need to use it as input for the wide-format table: PlotID, SpeciesLayer, and the values of abundance saved as CoverPerc. One more step is to select only these or deselect (-) those that are not needed.

```{r}
spe %>% 
  rename(PlotID = RELEVE_NR) %>%
  mutate(Species = str_replace_all(Species, " ", "_")) %>%
  unite("SpeciesLayer", Species, Layer, na.rm = TRUE, remove = FALSE) %>%
  select(PlotID, Species, Layer)
```

Now we can finally use the **`pivot_wider()`** function to transform the data. We need to specify where we are obtaining the names of new variables (**`names_from`**) and where we should get the values that should appear in the table (**`values_from`**).

```{r}
spe %>% 
  rename(PlotID = RELEVE_NR) %>%
  mutate(Species = str_replace_all(Species, " ", "_")) %>%
  unite("SpeciesLayer", Species, Layer, na.rm = TRUE, remove = TRUE) %>%
  pivot_wider(names_from = SpeciesLayer, values_from = CoverPerc)
```

There are different combinations of species in each plot, with some species present and others absent. Since we changed the format, all species, even those not occurring at that particular site or plot, must have some values. In long format, abundance or other information is not stored for absent species, so they are assigned NAs. Therefore, one additional step is to fill the empty cells with zeros using **values_fill**. In this case, we can do that because we know that if the species were absent, its abundance was exactly 0.

```{r}
spe %>% 
  rename(PlotID = RELEVE_NR) %>%
  mutate(Species = str_replace_all(Species, " ", "_")) %>%
  unite("SpeciesLayer", Species, Layer, na.rm = TRUE, remove = TRUE) %>%
  pivot_wider(names_from = SpeciesLayer, values_from = CoverPerc,
              values_fill = 0) -> spe_wide
```

## 4.3 From wide to long

Sometimes, it is necessary to transform data **from wide to long** format. Here, we need to say which column should not be changed, which is the PlotID (**`cols = -PlotID`**). Alternatively, `-1` would also work.

Then we specify what to do with the column names, how they should be saved (**names_to**). And how to call the column with values (**values_to**).

```{r}
spe_wide %>% 
  pivot_longer(cols = -PlotID, names_to = 'species', values_to = 'cover')
```

We need to remove the empty rows. Since we previously filled them with zeros, we will first complete the transformation and then filter out the rows with a cover equal to zero.

```{r}
spe_wide %>% 
  pivot_longer(cols = -PlotID, names_to = 'species', values_to = 'cover') %>%
  filter(!cover == 0)
```

Sometimes, we have data with NAs (not zeros). Here, it is very useful to use argument **`values_drop_na`**`= TRUE`.

```{r}
spe_wide %>% 
  pivot_longer(cols = -PlotID, names_to = 'species', values_to = 'cover', values_drop_na = TRUE)
```

## 4.4 `group_by()`, `count()`

Using the **`group_by()`** function, we can define how the data should be arranged into groups. Then we can proceed with asking questions about these groups. The basic function of summarising information is to count the number of rows.

In the first example, we are working with a species list in a long format. We can easily calculate the number of species in each plot/sample by counting the corresponding number of rows. First, you have to specify what the grouping variable is. In this case, it would be PlotID. And then you can directly count.

```{r}
spe %>% 
  rename(PlotID = RELEVE_NR) %>%
  group_by(PlotID) %>%
  count()
```

`count()` returns the number of rows in a new variable called n. You can directly put an extra line in your code and rename it. e.g. `rename(SpeciesRichness = n)`. Note that in this case, we simply counted all the rows. However, we know that some woody species may be recorded in the tree vegetation layer as shrubs or as small juveniles, so we potentially calculated such species three times. We can experiment with the `distinct()` function and remove the layer information. Is there a difference in the resulting numbers?

```{r}
spe %>% 
  distinct(PlotID = RELEVE_NR, Species) %>%
  group_by(PlotID) %>%
  count() %>%
  rename(SpeciesRichness = n)
```

The `count()` function can also be used in other cases. For example, we are interested in how many rows/plots/samples in the table are assigned to vegetation types. We will upload a table with descriptive characteristics for each forest plot, named `env`, which is a shortcut often used for an environmental data file.

```{r}
env <- read_excel("data/forest_understory/Axmanova-Forest-env.xlsx")
tibble(env)
```

And calculate the number of plots in each forest type.

```{r}
env %>% 
  group_by(ForestTypeName) %>% 
  count() 
```

**We can even skip the `group_by()` step** and directly specify what to count, which is very useful.

```{r}
env %>% 
  count(ForestTypeName)
```

The `count()` function can be very useful for checking duplicate rows. You can ask to count, for example, IDs in the file where you expect a unique ID in each row and filter those results that have more occurrences than 1. In the example below, each ID was used just once, so the filter returns no rows. Such a check is especially important if you need to append additional information using join functions.

```{r}
env %>% 
  count(PlotID = RELEVE_NR) %>%
  filter(n > 1)
```

## 4.5 `summarise()`

Using **`group_by()`** and **`summarise()`**, we can calculate, for example, the mean values or the total sum of values within a group. See more in the further reading. Here is an example of a `summarise()` for environmental data:

```{r}
env %>% 
  group_by(ForestTypeName) %>%
  summarise(meanBiomass = mean(Biomass))
```

`summarise()` is also very useful for species data. For example, we can calculate the total abundance, approximated as cover, of all plants in the plot/sample. Later on, we can ask about the relative share of parasites, endangered species, or alien species. Alternatively, we can calculate the community mean of specific traits, such as the mean height of the plants or their mean leaf area index. For this, we would have to append new information so that we can leave it for the next chapter.

```{r}
spe %>% 
  group_by(PlotID = RELEVE_NR) %>%
  summarise(totalCover = sum(CoverPerc))
```

We can also define more variables we want to summarise and more functions we want to apply. Try to find out more [`here`](https://dplyr.tidyverse.org/reference/summarise_all.html). Below is an example of the iris dataset, where we calculated the minimum, mean, and maximum values for sepal length and width in different species.

```{r}
glimpse(iris)
```

```{r}
iris %>% 
  group_by(Species) %>%
  summarise(across(c(Sepal.Length, Sepal.Width), list(min = min, mean = mean, max = max)))
```

## 4.6 Exercises

1\. **Forest Understory Data** - download the data from the repository ([`Link to Github folder`](https://github.com/BotzoolDataAnalysis/BotzoolDataAnalysis.github.io/tree/main/DataManipulationVisualisation/data)`)` and save it into your project folder. This dataset is used in the chapter above; please use it to prepare your own script with remarks, copy, and train what is described above. Note that you will use species data in long format: `Axmanova-Forest-spe.xlsx`, and environmental data `Axmanova-Forest-env.xlsx`

2\. Use the **Spruce forest data** used in the graphical example at the beginning of this chapter. *2a,* Import `spruce_forestWIDE.xlsx` \> transform *wide to long* format \> keep only true presences \> calculate species richness for each site (count of number of species). *2b,* Import also `spruce_forestLONG.xlsx` \> and transform *long to wide* format.

3\. Train the transformation of *wide to long* with another dataset, **Acidophilous grasslands,** namely the species file called `SW_moravia_acidgrass_species.csv`. Import the data and check the structure. Then, transform the format to long and remove absences. \*Use the `separate_wider_delim()` function to separate information about the species name and layer into two variables.

4\. Work with the dataset **Lepidoptera**, namely `spe_matrix_MSvejnoha`, which is the species file with counts of moths in forest steppe localities. Import the data and check the structure \> transform to long format \> count number of individuals at each site \> create barplot to visualise the differences (ggplot2, geom_col). \*For comparison, you can calculate the number of species (unique names) and visualise this as well.

5\. Use **Forest understory environmental data** `Axmanova-Forest-env.xlsx`\> prepare a new variable which will combine Forest type code and name (unite) \> calculate mean values of biomass for these forest types (group_by, summarise) \> prepare a graph with boxplots of forest type and biomass (ggplot2, geom_boxplot). \*You can also play more with the data, calculate min, mean and max values for biomass and soil pH at once.

6\. We will use the **iris dataset** integrated in R. Use glimpse(iris) to check the structure \> if needed, change the format to tibble using the `as_tibble()` function (`iris.data <- iris %>% as_tibble()`) \> calculate median values for selected parameters within different iris species.

> 7\. “*Tidy datasets are all alike, but every messy dataset is messy in its own way.*” Hadley Wickham

Import `Example4` from the **`messy_data`** and try to find duplicate rows.

8\. \* Import `Example2` from the Messy data and try to make the data tidy with the use of the `separate()` function. This works in an opposite direction to `unite()`.

<!--add mutate ifelse with other symbols  -->

<!--unite and separate with different separator  -->

## 4.7 Further reading

Summarise: <https://dplyr.tidyverse.org/reference/summarise.html>

Summarise multiple columns: <https://dplyr.tidyverse.org/reference/summarise_all.html>

Data transformation in R for Data Science: <https://r4ds.hadley.nz/data-transform.html>

Data tidying, including pivoting: <https://r4ds.hadley.nz/data-tidy.html>
